<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="./js/socket.io.js"></script>
<script src="./js/three.min.js"></script>
<script src="./js/FirstPersonControls.js"></script>
<script src="js/GLTFLoader.js"></script>
<script>

    String.prototype.format= function(){
        //将arguments转化为数组（ES5中并非严格的数组）
        var args = Array.prototype.slice.call(arguments);
        var count=0;
        //通过正则替换%s
        return this.replace(/{}/g,function(s,i){
            return args[count++];
        });
    }

    const socket = io('ws://localhost:3000');
    console.log("socket is {}.".format(socket));
    // Our Javascript will go here.
    // 创建场景
    const scene = new THREE.Scene(); //包含摄像机、地形、天空盒子等
    console.log("scene is {} ".format(scene));
    // 渲染时可以在不同场景之间切换
    //负责游戏对象的创建和销毁
    //游戏的每一个关卡对应一个场景

    // 添加摄像机
    const SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
    const VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.3, FAR = 1000;
    console.log('screen info: {} and {}.'.format(SCREEN_WIDTH, SCREEN_HEIGHT));
    const camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    camera.position.set(0, 20, 50);
    camera.lookAt(new THREE.Vector3(0, 15, 0)); // 不能直接lookat三个数字！必须是vector3对象！
    scene.add(camera);

    // 创建渲染器
    const renderer = new THREE.WebGLRenderer({antialias: true}); // 抗锯齿
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    document.body.appendChild(renderer.domElement); // 将渲染器内部的canvas对象添加到body中


    // // 创建渲染回调函数
    // function render() {
    //     requestAnimationFrame(render);
    //     renderer.render(scene, camera);
    // }
    // render();
    // 添加环境光
    // soft white light
    const light = new THREE.AmbientLight( 0xaaaaaa );
    scene.add( light );

    // 天空盒子
    const skyBoxGeometry = new THREE.BoxGeometry(500, 500, 500);

    // 接下来创建材质并映射到指定图片，设定为只渲染背面(对立方体来说，从外面看到的是正面，从内部看到的是背面)
    const textureLoader = new THREE.TextureLoader();
    const skyBoxMaterial = [
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/px.jpg'), side: THREE.BackSide}), // right
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/nx.jpg'), side: THREE.BackSide}), // left
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/py.jpg'), side: THREE.BackSide}), // top
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/ny.jpg'), side: THREE.BackSide}), // bottom
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/pz.jpg'), side: THREE.BackSide}), // back
        new THREE.MeshBasicMaterial({map: textureLoader.load('./assets/textures/skybox/nz.jpg'), side: THREE.BackSide}) // front
    ];

    // 创建天空盒子并添加到场景
    const skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
    scene.add(skyBox);

    // 添加地板
    // 纹理：横向和纵向都重复四次
    textureLoader.load("./assets/textures/floor/FloorsCheckerboard_S_Diffuse.jpg", function (texture) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(4, 4);
        const floorMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide });
        const floorGeometry = new THREE.PlaneGeometry(500, 500, 5, 5); const floor = new THREE.Mesh(floorGeometry, floorMaterial); floor.position.y = 0;
        floor.rotation.x = Math.PI / 2;
        scene.add(floor);
    })

    let playerMap = new Map();
    // 添加控制
    // pointer lock 鼠标光标的锁定
    const fpc = new FirstPersonControls(camera, document.body, playerMap);
    fpc.connect();

    // 通过鼠标移动来控制相机的旋转
    scene.add(fpc.yawObject);

    //通过键盘控制相机的移动

    let clock = new THREE.Clock(); // 通过Clock对象计算delta
    function render() {
        fpc.update(clock.getDelta());
        socket.emit('player', {position: fpc.yawObject.position, rotation: fpc.yawObject.rotation});
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

    window.addEventListener("resize", onWindowResize);
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }



    socket.on('player', data => {
        if (playerMap.has(data.socketid)) {
            let model = playerMap.get(data.socketid);
            model.position.set(data.position.x, data.position.y, data.position.z);
            model.rotation.set(data.rotation._x, data.rotation._y + Math.PI / 2, data.rotation._z);
        } else {
            console.log('else first : {}'.format(playerMap.has(data.socketid)));
            socket.emit('player', {position: fpc.yawObject.position, rotation: fpc.yawObject.rotation});
            const loader = new THREE.GLTFLoader();
            loader.load("./assets/models/duck.glb", (mesh) => {
            console.log('else second : {}'.format(playerMap.has(data.socketid)));
                //如果这个判断注释掉会怎么样，为什么
                if(!playerMap.has(data.socketid)) {
                    console.log('else + if : {} '.format(playerMap.has(data.socketid)));
                    mesh.scene.scale.set(10, 10, 10);
                    scene.add(mesh.scene);
                    playerMap.set(data.socketid, mesh.scene);
                    let model = playerMap.get(data.socketid);
                }
            });
        }
    });

    socket.on('offline', data => {
        if (playerMap.has(data.socketid)) {
            scene.remove(playerMap.get(data.socketid));
            playerMap.delete(data.socketid)
        }
    });

    render();

</script>
</body>
</html>
